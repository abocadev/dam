#########################
### CAMPOS CALCULADOS ###
#########################

Lo que tendremos que hacer es crear un nuevo campo y haremos lo siguiente:

	"""
	alter table Facturas
		add Campo as (Operacion)
	"""
	
Una formula de un campo calculado no puede estar dentro de otro campo calculado.

Entonces por ejemplo si queremos crear un campo calculado utilizando otro campo calculado, lo que tendremos que hacer es la siguiente:

	"""
	alter table Tabla
		add Campo2 as (Operacion - (Operacion tabla anterior))
	"""
	

############################################
### PROCEDIMIENTOS ALMACENADOS (Parte 1) ###
############################################

Para poder crear un procedimiento almacenado, lo que tendremos que hacer es irnos a la BD --> "Programmability" --> "Stored Procedures" y le damos a Click Derecho y le damos a "Stored Procedure...".

Lo primero que haremos sera poner

"""
create procedure [NOMBRE DE LA FUNCION]

AS
BEGIN
	[Aquí iria todo el código]
END 
GO
"""

Para poder declarar una variable:

	"""
	declare @i int [La creamos]
	set @i = 5 [Para establecer un valor]
	"""
	
Para mostrar el valor de @i, lo que tendremos que hacer es:

"""
select @i
"""

Una vez que ejecutemos este código, nos volvemos a la pestaña de donde esta la BD BD --> "Programmability" --> "Stored Procedures" y si le damos a la tecla "F5", nos saldra la nueva función.

Si lo queremos ejecutar, nos dirigiremos dentro de la funcion y le daremos a click derecho a la funcion y le daremos a execute. Nos saldra una pestaña y lo que haremos será darle a OK.

Para poder utilizar un "procedure" que ya esta creado, lo que tendremos que hacer es lo siguiente:

"""
ALTER PROCEDURE [Nombre de la función]

AS
BEGIN
	[Aquí iria todo el código]
END 
GO
"""

Para poder asignar un select a una variable, lo que tendremos que hacer es lo siguiente:

"""
create procedure [NOMBRE DE LA FUNCION]

AS
BEGIN
	declare @i decimal
	set @i = (SELECT SUM(Importe) FROM Facturas)
	
	select @i
END 
GO
"""

Si queremos hacer dos selects lo que tendremos que hacer es lo siguiente:

"""
select @i, @a
"""

Si queremos hacer dos select en un select y queremos insertar el valor en dos variables diferentes, tendremos que hacer lo siguiente:

"""
select @importe = sum(Importe), @importeDescuento = sum(ImporteDescuento) from Facturas
"""

Si queremos hacer una condición, lo que tendremos que hacer es lo siguiente:

"""
if(@Importe > 10000) BEGIN
	Update Facturas set Descuento = Descuento * 10
END ELSE BEGIN
	
END
"""

Como generar un bucle "while":

"""
ALTER PROCEDURE [Nombre de la función]

AS
BEGIN
	declare @contador int
	set @contador = 0
	
	while(@contador  < 5) BEGIN
		select @contador = @contador + 1
	END
END 
GO
"""

############################################
### PROCEDIMIENTOS ALMACENADOS (Parte 2) ###
############################################

Utilizaremos la BD de un bar y crearemos un procedimiento almacenado que sirve para pedir un artículo para la mesa:

"""
CREATE PROCEDURE PedirArticuloMesa
	@MesaId int,
	@ArticuloId int
AS
BEGIN
	
	declare @TicketId int
	
	if((SELECT COUNT(*) FROM Ticket where MesaId = @MesaId and FechaCierre is Null) = 0) BEGIN
		-- no hay ticket abierto
		select 'Aqui ha entrado'
		INSERT INTO Ticket(MesaId)
		values (@MesaId)
		
		@TicketId = @@indetity
	END ELSE BEGIN
		-- si hay un ticket abierto
		select @TicketId = Id from Ticket where MesaId = @MesaId and FechaCierre is Null
	END
	
	if((select count(*) from linea where ArticuloId = @ArticuloId and TicketId = @TicketId)=0) BEGIN
		-- No existe el articulo en el ticket
		insert into Linea (TicketId,ArticuloId,Nombre,TipoIvaId,PrecioFinal,Unidades)
		select @TicketId, @ArticuloId, Nombre, TipoIvaId, PrecioFinal,0 from Articulo where Id = @ArticuloId
	END
	
	Update Linea set Unidades = Unidades + 1
	where TicketId = @TicketId AND ArticuloId = @ArticuloId
		
END
GO
"""

Para saber el ultimo ID creado en este entorno de ejecución lo que tendremos que hacer es lo siguiente:

"""
@MesaId = @@identity
"""

Para insertar valores en una base de datos utilizando un select, lo que tendremos que hacer es lo siguiente:

"""
insert into Linea (TicketId,ArticuloId,Nombre,TipoIvaId,PrecioFinal,Unidades)
select @TicketId, @ArticuloId, Nombre, TipoIvaId, PrecioFinal,0 from Articulo where Id = @ArticuloId
"""

Para mejorar el rendimiento lo que tendremos que hacer es un índice en un where de la siguiente manera:

	1. Lo primero que tendremos que hacer es irnos a la tabla y le tendremos que dar a click derecho de la tabla y le damos a "diseño".
	
	2. Ahora lo que haremos sera irnos a "Manage Indexs" y crearemos los índices que conpondran el where.
	

##########################
### FUNCIONES: PARTE I ###
##########################

Para poder crear una nueva función, lo que tendremos que hacer es irnos a la BD --> "Programmability" --> "Functions" --> "Scalar-Value Functions" y le daremos clic derecho y le damos a "Scalar-Value Functions..."

Y la estructura de la función es la siguiente:

"""
CREATE FUNCTION dbo.TotalTicket(
	[Los datos que va a coger la función]
)
RETURNS <Function_Date_Type, ,int>
AS BEGIN
	[Aquí pondremos lo que hara la función]
END
"""

Función del total de un ticket:

"""
CREATE FUNCTION dbo.TotalTicket(
	@TicketId int
)
RETURNS DECIMAL (10, 2)
AS BEGIN
	-- Aqui declararemos la variable de retorno
	DECLARE @ret DECIMAL (10, 2)
	
	-- Añadimos las declaraciones de T-SQL para poder darle valor a la variable de retorno
	SELECT @ret = sum(TotalLinea) from Linea where TicketId = @TicketId
	
	-- Añadimos el resultado de la función
	RETURN @ret
END
GO
"""

	AVISO: Las funciones no se pueden ejecutar, si no que se llaman
	
Para poder llamar a una función lo que tendremos que hacer es lo siguiente:

"""
SELECT *, dbo.TotalTicket(Id) FROM Ticket
"""

Ahora añadiremos esta función a un campo calculado, para ello lo que tendremos que hacer es lo siguiente:

"""
ALTER TABLE ticket
	ADD TotalTicket AS dbo.TotalTicket(Id)
"""

###########################
### FUNCIONES: PARTE II ###
###########################

Ahora en estos momentos lo que haremos será crear una función para saber el total de un ticket:

"""
CREATE FUNCTION [dbo].[TotalTicket]
(
	@TicketId int
)

RETURNS decimal (10, 2)
AS BEGIN
	-- Aqui declararemos la variable de retorno
	DECLARE @ret DECIMAL (10, 2)
	
	-- Añadimos las declaraciones de T-SQL para poder darle valor a la variable de retorno
	SELECT @ret = sum(TotalLinea) from Linea where TicketId = @TicketId
	
	-- Añadimos el resultado de la función
	RETURN @ret
END
GO
"""

Y para que esto se añada a un campo calculado lo que tendremos que hacer es lo siguiente:

"""
ALTER TABLE Ticket
	add TotalTicket AS dbo.TotalTicket(Id)
"""

Para saber si una mesa no esta cerrada, lo que tendremos que hacer es una función que es la siguiente:

"""
CREATE FUNCTION [dbo].[TicketAbierto]
(
	@MesaId int
)

RETURNS bit
AS BEGIN
	-- Aqui declararemos la variable de retorno
	DECLARE @ret bit
	
	-- Añadimos las declaraciones de T-SQL para poder darle valor a la variable de retorno
	select @ret = count(*) from Ticket where MesaId = @MesaId and FechaCierre is null
	
	-- Añadimos el resultado de la función
	RETURN @ret
END
GO
"""

Y lo añadimos en un campo calculado:

"""
ALTER TABLE Mesa
	ADD TicketAbierto AS dbo.TicketAbierto(Id)
"""

Ahora lo que haremos será pasar un Tipo de Iva (que el valor será tipo "int") y lo que haremos será devolver el porcentaje:

"""
CREATE FUNCTION [dbo].[PorcentajeIva]
(
	@TipoIvaId int
)

RETURNS decimal (18, 2)
AS BEGIN
	-- Aqui declararemos la variable de retorno
	DECLARE @ret DECIMAL (18, 2)
	
	-- Añadimos las declaraciones de T-SQL para poder darle valor a la variable de retorno
	SELECT @ret = PorcentajeIva from TipoIva where id = @TipoIvaId
	
	-- Añadimos el resultado de la función
	RETURN @ret
END
GO
"""

Y lo añadimos a un campo calculado:

"""
ALTER TABLE Linea
	ADD PorcentajeIva as dbo.PorcentajeIva(TipoIvaId)
"""

Ahora lo que haremos será quitarle el Iva del producto:

"""
select *, TotalLinea/(1+(PorcentajeIva/100)) from Linea
"""

Y para ponerlo en un campo calculado lo que tendremos que hacer es lo siguiente:

"""
ALTER TABLE Linea
	ADD PrecioSinIva AS (PrecioFinal + Unidades)/(1 + (dbo.PorcentajeIva(TipoIvaId)/100))
"""

Ahora lo que haremos será crear el ImporteIva:

"""
CREATE FUNCTION [dbo].[ImporteIva]
(
	@TicketId int
)

RETURNS decimal (10, 2)
AS BEGIN
	-- Aqui declararemos la variable de retorno
	DECLARE @ret DECIMAL (10, 2)
	
	-- Añadimos las declaraciones de T-SQL para poder darle valor a la variable de retorno
	SELECT @ret = sum(ImporteSinIva) from Linea where TicketId = @TicketId
	
	-- Añadimos el resultado de la función
	RETURN @ret
END
GO
"""

Y ahora lo que haremos será añadirlo a un campo calculado:

"""
ALTER TABLE Ticket
	ADD ImporteIva AS [dbo].[ImporteIva](Id)
ALTER TABLE Ticket
	ADD ImporteSinIva AS [dbo].[ImporteSinIva](Id)
"""

#########################
### 	S: PARTE I ###
#########################

Lo primero que haremos será crear un campo donde pondremos las ventas total del artículo,

"""
use Bar
alter table Articulo
	add Ventas int default 0 not null
	
	go
	
	update Articulo set Ventas = 0
	
	go
"""

Para poder añadir un Trigger lo que tendreemos que hacer es lo siguiente: BD --> Tables --> Tabla a la que queremos hacer un trigger --> Triggers --> Click Derecho "New Trigger"

Y la estructura del trigger es la siguiente:

"""
CREATE TRIGGER <Schema_Name, sysname, Schema_Name>.<Trigger_Name, sysname, Trigger_Name>
	ON <Schema_Name, sysname, Schema_Name>.<Table_Name, sysname, Table_Name>
	AFTER <Data_Modification_Statements, , INSERT, DELETE, UPDATE>
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
END
GO
"""

Ahora lo que haremos será crear un Trigger para la tabla Linea, para cuando insertemos un dato en esta tabla.

"""
CREATE TRIGGER trgActualizasVentas
	ON Linea
	AFTER INSERT
BEGIN
	UPDATE Articulo
	SET 
	Articulo.Ventas=Articulo.Ventas + Inserted.Unidades
	FROM Inserted
	INNER JOIN
	Articulo
	ON Articulo.Id = Inserted.ArticuloId
END
GO
"""

Esta es una plantilla para hacer un "sql update from select":

"""
UPDATE Per
SET 
Per.PersonCityName=Addr.City, 
Per.PersonPostCode=Addr.PostCode
FROM Persons Per
INNER JOIN
AddressList Addr
ON Per.PersonId = Addr.PersonId
"""

AVISO: Diferencia entre TRUNCATE y DELETE:
	TRUNCATE: Borra la tabla y la vuelve a recrear.
	DELETE: Borra la tabla.
